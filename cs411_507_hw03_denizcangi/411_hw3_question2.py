# -*- coding: utf-8 -*-
"""411_hw3_question2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a6Ha5eHzzf2pMyZ949yCJ5UtNY5ZY8YC
"""

import copy 

z = [0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1]
def LFSR(C, S):
    L = len(S)
    fb = 0
    out = S[L-1]
    for i in range(0,L):
        fb = fb^(S[i]&C[i+1])
    for i in range(L-1,0,-1):
        S[i] = S[i-1]

    S[0] = fb
    return out

def FindPeriod(s):
    n = len(s)
    for T in range(1,n+1):
        chck = 0
        for i in range(0,n-T-1):
            if (s[i] != s[i+T]):
                chck += 1
                break
        if chck == 0:
            break
    if T > n/2:
        return n
    else:
        return T        

def PolPrune(P):
    n = len(P)
    i = n-1
    while (P[i] == 0):
        del P[i]
        i = i-1
    return i

def PolDeg(P):
    n = len(P)
    i = n-1
    while (P[i] == 0):
        i = i-1
    return i

# P gets Q
def PolCopy(Q, P):
    degP = len(P)
    degQ = len(Q)
    if degP >= degQ:
        for i in range(0,degQ):
            Q[i] = P[i]
        for i in range(degQ, degP):
            Q.append(P[i])
    else: # degP < deqQ
        for i in range(0,degP):
            Q[i] = P[i]
        for i in range(degP, degQ):
            Q[i] = 0
        PolPrune(Q)           

def BM(s):
    n = len(s)

    C = []
    B = []
    T = []
    L = 0
    m = -1
    i = 0
    C.append(1)
    B.append(1)

    while(i<n):
        delta = 0
        clen = len(C)
        for j in range(0, clen):
            delta ^= (C[j]*s[i-j])
        if delta == 1:
            dif = i-m
            PolCopy(T, C)
            nlen = len(B)+dif
            if(clen >= nlen):
                for j in range(dif,nlen):
                    C[j] = C[j] ^ B[j-dif]
            else: # increase the degree of C
                for j in range(clen, nlen):
                    C.append(0)
                for j in range(dif, nlen):
                    C[j] = C[j] ^ B[j-dif]
            PolPrune(C)
            if L <= i/2:
                L = i+1-L
                m = i
                PolCopy(B, T)  
        i = i+1    
    return L, C


def formTheArray(all,arr, n):  

  new_array = []
  
  for i in range(0, n):  
      new_array.append(arr[i]) 
      
  all.append(new_array)

#this function generate all binary strings of length n and keep all of them in a list called all
def generateAllBinaryStrings(all,n, arr, i):  
  
  if i == n: 
    formTheArray(all,arr,n)
    return 

  arr[i] = 0
  generateAllBinaryStrings(all,n, arr, i + 1)  

  arr[i] = 1
  generateAllBinaryStrings(all,n, arr, i + 1) 

#count the number of matching bits between x and z 
def count_matchingbits(x):

  count = 0

  for i in range(len(z)):
    if z[i] == x[i]:
      count += 1
  
  return count

#function to find the initial states of LFSR1 and LFSR3
#function takes a,b,c which are the powers of x that have tconstant 1 in connection polynomial and L which is the degree of connection polynomial
def findInitial(a,b,c,L):

  length = len(z)
  C = [0]*(L+1)
      
  C[a] = C[b] = C[c] = 1 #create the connection polynomial

  arr = [None] * L
  all=[]

  #generate all binary strings of length L, which are all the possible initial states
  generateAllBinaryStrings(all, L, arr, 0)

  #max_count keeps the maximum number of matching bits with z
  #initial keeps the initial state which has generated the key stream with maximum number of matching bits with z
  #key keeps the keystream that have the maximum number of matching bits with z which is generated by the initial
  max_count = 0
  initial = [0]*L
  key = [0]*length

  #this for loop go through all the possible initial states in list all
  for initial_state in all:
    initial_temp = list(initial_state) #copy the initial state in temp list since LFSR function changes the initial state
    #generate the key stream of length length with the initial state initial_state
    keystream = [0]*length
    for j in range(0,length):
      keystream[j] = LFSR(C, initial_state)
    #find the number of matching b,ts
    count = count_matchingbits(keystream)
    #if count is more than max_count then initial state is initial_temp, key is keystream and new max_count is count
    if count > max_count:

      initial = list(initial_temp)
      key = list(keystream)
      max_count = int(count)

  #in last return the initial and key which has generated the maximum number of matching bits with output sequence z
  return initial,key

#get the initial state of LFSR1 and key stream of LFSR1
initial_1, keystream_1 = findInitial(0, 5, 14, 14)
print("Initial of LFSR1",initial_1)
print("Keystream is",keystream_1)
print()

#get the initial state of LFSR3 and key stream of LFSR3
initial_3, keystream_3 = findInitial(0,2,11,11)
print("Initial of LFSR3",initial_3)
print("Keystream is",keystream_3)
print()

#under this part we try to find initial state and keystream for LFSR2
length = len(z)
L = 17
C = [0]*(L+1)
C[0] = C[3] = C[17] = 1 #x17+ x3 + 1


arr = [None] * L
all=[]

#keep all of the possible initial states of the LFSR2 in all list
generateAllBinaryStrings(all, L, arr, 0)

initial_2 = []
keystream_2 = []

#for all the possible initial state
for initialstate in all:

  initial_temp = list(initialstate)

  keystream = [0]*length
  count = 0
  for j in range(0,length):
    keystream[j] = LFSR(C, initialstate) #generate the jth index of keystream for LFSR2
    #and then find the key bit that will be generated with geffe generator using keystream of LFSR1, LFSR2 and LFSR3
    bit = (keystream_1[j] & keystream[j]) ^ (keystream[j] & keystream_3[j]) ^ keystream_3[j]
    #if it's not equal to the jth index of z then we don't need to keep generating the rest of keystream 
    #because this initialstate is not the one that we're looking
    #since the initial state that generates the keystream does not generate z with geffe generator
    if bit != z[j]:
      break
    #if they're equal then increment count by 1 and keep generating the keystream
    else:
      count = count + 1
  
  #if count is equal to length of z then all the bits generated with geffe generator is equal to z 
  #and we have found the initial state and keystream that's generated by this initial state for LFSR2 
  if count == length:
    initial_2 = list(initial_temp)
    keystream_2 = list(keystream)
    break

print("Initial of LFSR2",initial_2)
print("Keystream is", keystream_2)

#temp_z = []
#for l in range(length):
#  key_bit = (keystream_1[l] & keystream_2[l]) ^ (keystream_2[l] & keystream_3[l]) ^ keystream_3[l]
#  temp_z.append(key_bit)

#if z == temp_z:
#  print("finished")