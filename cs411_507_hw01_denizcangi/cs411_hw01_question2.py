# -*- coding: utf-8 -*-
"""cs411_hw01_question2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AVukmP_As4YfFIlZMv5KDIiklmueJUZk
"""

letter_count = {'A':0, 'B':0, 'C':0, 'D':0, 'E':0, 'F':0, 'G':0, 'H':0, 'I':0,
         'J':0, 'K':0, 'L':0, 'M':0, 'N':0, 'O':0, 'P':0, 'Q':0,
         'R':0, 'S':0,  'T':0, 'U':0, 'V':0, 'W':0, 'X':0, 'Y':0, 'Z':0}
inv_uppercase = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H',
                 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P',
                 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X',
                 24:'Y', 25:'Z'}
uppercase ={'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8,
         'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16,
         'R':17, 'S':18,  'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24,
         'Z':25}
lowercase = {'a':0, 'b':1, 'c':2, 'd':3, 'e':4, 'f':5, 'g':6, 'h':7, 'i':8,
         'j':9, 'k':10, 'l':11, 'm':12, 'n':13, 'o':14, 'p':15, 'q':16,
         'r':17, 's':18,  't':19, 'u':20, 'v':21, 'w':22, 'x':23, 'y':24,
         'z':25}
inv_lowercase = {0:'a', 1:'b', 2:'c', 3:'d', 4:'e', 5:'f', 6:'g', 7:'h', 8:'i',
         9:'j', 10:'k', 11:'l', 12:'m', 13:'n', 14:'o', 15:'p', 16:'q',
         17:'r', 18:'s', 19:'t', 20:'u', 21:'v', 22:'w', 23:'x', 24:'y',
         25:'z'}

# The extended Euclidean algorithm (EEA)
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

def modinv(a, m):
    if a < 0:
        a = m+a
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

def countTheLetters(text): #function that count the letters in the given text

  for char in text:
    char = char.upper()

    if char in letter_count:
      letter_count[char] = letter_count[char]+1

  sort_letters = sorted(letter_count.items(), key=lambda x: x[1], reverse=True) #sort them in decreasing order and return the most common one
  #print(sort_letters)

  mostCommonLetter = sort_letters[0][0]

  return mostCommonLetter

def findAlphaBetaPairs(plain, cipher): #find all the alpha beta pairs with the fact that alpha should be relatively prime with 26

  alphalist=[1,3,5,7,9,11,15,17,19,21,23,25] #numbers that are less than 26 and relatively prime with 26
  plainNum= uppercase[plain]
  cipherNum= uppercase[cipher]
  betalist=[]

  for alpha in alphalist: #find the corresponding beta values for each possible alpha values using the given plain and corresponding ciphertext letter
    beta = (cipherNum - alpha * plainNum)%26
    betalist.append(beta)
  
  alpha_beta_tuple = list(zip(alphalist,betalist))

  return alpha_beta_tuple

text = "Xpjjbxx lx eng klerm, krlmpob lx eng krgrm: lg lx gcb jnportb gn jneglepb gcrg jnpegx."

mostCommonLetter = countTheLetters(text)
print("Most common lettter in the ciphertext is:", mostCommonLetter)
alpha_beta_tuple = findAlphaBetaPairs('T', mostCommonLetter) #we know that the most common letter in the plaimntext is T

def Affine_Dec(ptext, key): #using the keys we decrypt the message
    plen = len(ptext)
    ctext = ''
    for i in range (0,plen):
        letter = ptext[i]
        if letter in lowercase:
            poz = lowercase[letter]
            poz = (key.gamma*poz+key.theta)%26
            #print poz
            ctext += inv_lowercase[poz]
        elif letter in uppercase:
            poz = uppercase[letter]
            poz = (key.gamma*poz+key.theta)%26
            ctext += inv_uppercase[poz]
        else:
            ctext += ptext[i]
    return ctext

# key object for Affine cipher
# (alpha, beta) is the encryption key
# (gamma, theta) is the decryption key
class key(object):
    alpha=0
    beta=0
    gamma=0
    theta=0

# A simple example

for pairs in range(len(alpha_beta_tuple)):
  key.alpha = alpha_beta_tuple[pairs][0]
  key.beta = alpha_beta_tuple[pairs][1]
  key.gamma = modinv(key.alpha, 26) # you can compute decryption key from encryption key
  key.theta = 26-(key.gamma*key.beta)%26

  dtext = Affine_Dec(text, key)
  if key.alpha==9:
    print("Encryption keys are alpha =", key.alpha, "and beta =", key.beta)
    print("Decryption keys are gamma =", key.gamma, "and theta =", key.theta)
    print()
    print("Plaintext that we are looking for is: ", dtext)