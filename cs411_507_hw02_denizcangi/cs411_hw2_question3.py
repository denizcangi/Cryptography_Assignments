# -*- coding: utf-8 -*-
"""cs411_hw2_question3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-qcRvuHCKeeWdPD8nydWx3ZSsbEj-ysc
"""

def gcd(a, b):
    
    while b:
        a, b = b, a%b
    return a

def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

def congruences(n, a, b):
  list_solutions = []
  gcd_an = gcd(a,n)
  print(gcd_an)
  if gcd_an == 1:

    x = (b * modinv(a,n)) % n
    list_solutions.append(x)

  elif b % gcd_an == 0:

    x = ((b//gcd_an) * modinv(a//gcd_an, n//gcd_an)) % (n//gcd_an)

    for i in range(gcd_an):
      list_solutions.append(x)
      x = x + (n//gcd_an)

  else:

    print("NO SOLUTIONS!")
  
  return list_solutions


n = 97289040915427312142046186233204893375 
a = 74945727802091171826938590498744274413 
b = 54949907590247169540755431623509626593  

list_of_solutions = congruences(n,a,b)
print(list_of_solutions)