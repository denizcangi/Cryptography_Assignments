# -*- coding: utf-8 -*-
"""cs411_hw2_question2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/135Xphegyy_gdYGZVd5eXAGdnm-xP5ilC
"""

import requests
import math

API_URL = 'http://cryptlygos.pythonanywhere.com'

my_id = 25427

endpoint = '{}/{}/{}'.format(API_URL, "q2", my_id )
response = requests.get(endpoint) 	
if response.ok:	
  r = response.json()
  p, q, e, c = r['p'], r['q'], r['e'], r['cipher']    #Use these variables to calculate m
  print(c)
else:  print(response.json())

##SOLUTION
def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
    gcd = b
    return gcd, x, y

def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None  # modular inverse does not exist
    else:
        return x % m

def expmod_R2L(a,e,n):
  x = 1
  y = a

  while e != 0:

    if e % 2 == 1:
      x = (x*y) % n

    y = (y**2) % n
    e = e >>1

  return x%n

def find_m():

  n = p*q
  phi_of_n = (p-1) * (q-1)
  d = modinv(e, phi_of_n)

  return expmod_R2L(c,d,n)

## END OF SOLUTION


m = find_m() 	#ATTN: change this into the number you calculated and DECODE it into a string m_
m_ = m.to_bytes((m.bit_length() // 8) + 1, byteorder='big').decode("utf-8")

#query result
endpoint = '{}/{}/{}/{}'.format(API_URL, "q2c", my_id, m_ )    #send your answer as a string
response = requests.put(endpoint) 	
print(response.json())